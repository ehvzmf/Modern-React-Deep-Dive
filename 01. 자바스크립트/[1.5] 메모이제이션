<aside>
💡

- `useMemo`, `useCallback` 훅과 고차 컴포넌트 `memo`는 리액트에서 발생하는 렌더링을 최소한을 줄이기 위해 제공
- 메모이제이션 기법이 최적화에 사용되는 것뿐 아니라 정확히 언제 사용하는 게 좋을지 생각해보자.
    - 렌더링이 자주 일어나는 컴포넌트를 어떻게 알 수 있을까?
    - 의존성 배열이 생략된 useEffect를 모든 컴포넌트에 추가해 실제로 렌더링이 돌아가는지 확인해야 할까?
    - 무거운 연산의 기준은 뭘까?
    - 실제로 코드 작성 시 함수 실행 속도/컴포넌트 렌더링 속도를 매번 계싼하는 게 좋을까?
    - 그 기준은 뭘까?
- 이런 질문들의 주장을 살펴보고, 현명하고 효율적으로 리액트에서 메모이제이션하는 법을 알아보자.
</aside>

# 섣부른 최적화는 독?

---

> 꼭 필요한 곳에만 메모이제이션을 추가하자. 
메모이제이션도 비용이 드는 작업이므로, 최적화에 대한 비용을 지불할 땐 신중해야 한다.
> 
- 가벼운 작업 자체는 메모이제이션보다 매번 작업을 수행하는 게 빠를 수 있다.
- 메모이제이션의 비용
    - 값을 비교하고 렌더링/재계산이 필요한지 확인하는 작업
    - 이전에 결과물을 저장해 두었다가 다시 꺼내오는 작업
- 상황에 따라 위 비용과 리렌더링 비용이 다를 수 있으니 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.
    - premature optimization/memorization
- 리액트에서 진작 모든 컴포넌트를 `PureComponent` 로 만들었거나 `memo`로 감싸두는 작업을 하지 않은 이유
    - 댄 아브라모프(리액트 개발자) “아무데서나 PureComponent를 쓰지 마세요. … 왜 lodash의 모든 함수에 memoize()를 사용하지 않나요? 벤치마크로 성능을 확인해봐야지 않나요?”
    - 메모이제이션은 어느 정도 트레이드 오프 존재
        - 이전 결과를 캐시로 저장해 미래의 성능을 위해 메모리를 차례대로 점유
    - 리액트 공식 문서 - `useMemo`의 성능 최적화를 보장할 수 없으며, 미래에 캐시 무효화 가능성 언급
- 미리 렌더링이 많이 될 것 같은 부분을 예측해 섣부른 최적화를 하지 말자.
- 애플리케이션을 어느 정도 만들며, 개발자 도구나 useEffect를 사용해 실제로 렌더링을 확인해보고 필요한 곳에만 사용하자.

# 렌더링 비용! 무조건 최적화

---

- 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다.
    - 자주 렌더링되고, 비싼 연산이 포함되어 있고, 자식 컴포넌트가 많다면 `memo`등 메모이제이션을 사용하는 것이 분명히 이로울 수 있다.
    - 컴포넌트 사용에 따라 잘 살펴보고 일부에만 적용하는 법은 이상적이지만, 애플리케이션 규모, 개발자 수, 컴포넌트의 복잡성에 따라 적용할 수 없다.
- 일단  `memo`를 다 적용하자.
    - 잘못된 `memo` 로 지불해야 하는 비용 - `props`에 대한 얕은 비교가 발생하면서 지불해야 하는 비용
    - 메모이제이션은 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해두고, 리렌더링할 필요가 없다면 이전 결과물 사용
    - 리액트의 기본적인 재조정 알고리즘은 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장
    - 어차피 이전 결과물은 저장되므로, `memo`로 지불해야 하는 비용은 `props`에 대한 얕은 비교뿐이다.
    - 물론 `props`가 크고 복잡해진다면 이 비용 또한 커질 수 있다.
- `memo`를 적용하지 않았을 경우 발생 가능한 문제
    - 렌더링을 함으로써 발생하는 비용
    - 컴포넌트 내부의 복잡한 로직의 재실행
    - 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복 발생
    - 리액트가 구 트리와 신규 트리 비교
- `useMemo`, `useCallback`
    - 의존성 배열 비교, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중 무엇이 더 저렴한지 매번 계산 필요
    - 리렌더링 시 모든 객체는 재생성되고 결과적으로 참조는 달라지게 된다.
        - `useEffect` 같은 의존성 배열에 쓰일 경우 변경된 참조로 다른 쪽에 영향
